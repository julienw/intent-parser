{"version":3,"file":null,"sources":["../src/cleaners/normalise-cleaner.js","../src/cleaners/contractions-cleaner.js","../src/cleaners/salutations-cleaner.js","../src/cleaners/politeness-cleaner.js","../src/cleaners/questions-cleaner.js","../src/parsers/chrono/chrono.js","../src/parsers/time-parser.js","../src/parsers/users-parser.js","../src/parsers/action-parser.js","../src/refiners/confirmations/reminder-confirmation.js","../src/refiners/reminder-refiner.js","../src/refiners/confirmations/query-confirmation.js","../src/refiners/query-refiner.js","../src/intent-parser.js"],"sourcesContent":["export default class NormaliseCleaner {\n  clean(obj = { raw: '' }) {\n    const text = obj.raw\n    // Normalise whitespace to space.\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    // Let's use the normalised text for the rest of the processing.\n    obj.text = text;\n    obj.cleaned = text;\n\n    return Promise.resolve(obj);\n  }\n}\n","export default class ContractionsCleaner {\n  clean(obj = { cleaned: '' }) {\n    const cleaned = obj.cleaned\n    // Unambiguous cases.\n      .replace(/\\b(let)'s\\b/ig, '$1 us') // Keep the case.\n      .replace(/'s (been|got|gotten)\\b/ig, ' has $1')\n      .replace(/'s (being|going)\\b/ig, ' is $1')\n      .replace(/'d (like|love)\\b/ig, ' would $1')\n\n      // Irregular negations.\n      .replace(/\\b(should)n't've\\b/ig, '$1 not have')\n      .replace(/\\b(would)n't've\\b/ig, '$1 not have')\n      .replace(/\\b(could)n't've\\b/ig, '$1 not have')\n      .replace(/\\b(s)han't\\b/ig, '$1hall not') // Keep the first letter case.\n      .replace(/\\b(w)on't\\b/ig, '$1ill not')\n      .replace(/\\b(c)an't\\b/ig, '$1annot')\n\n      // Regular contractions.\n      .replace(new RegExp('\\\\b(' +\n        'am|are|could|did|do|does|had|has|have|' +\n        'is|might|must|should|was|were|would' +\n        ')n\\'t\\\\b', 'ig'), '$1 not')\n      .replace(/\\b(g)onna\\b/ig, '$1oing to') // Keep the first letter case.\n      .replace(/\\b(w)anna\\b/ig, '$1ant to')\n      .replace(/'ll\\b/ig, ' will')\n      .replace(/'re\\b/ig, ' are')\n      .replace(/'ve\\b/ig, ' have')\n      .replace(/'m\\b/ig, ' am');\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","const PUNCTUATION = {\n  // @see http://www.unicode.org/cldr/charts/29/summary/en.html#4\n  en: '[-‐–—,;:!?.…\\'‘’\"“”()[\\\\]§@*/&#†‡′″]',\n  fr: '[-‐–—,;:!?.…’\"“”«»()[\\\\]§@*/&#†‡]',\n  ja: '[-‾_＿－‐—―〜・･,，、､;；:：!！?？.．‥…。｡＇‘’\"＂“”(（)）\\\\[［\\\\]］{｛}｝' +\n  '〈〉《》「｢」｣『』【】〔〕‖§¶@＠*＊/／\\\\＼&＆#＃%％‰†‡′″〃※]',\n};\n\nexport default class SalutationsCleaner {\n  clean(obj = { cleaned: '' }) {\n    const cleaned = obj.cleaned\n      .replace(\n        new RegExp(`^(?:Hello|Hey|Hi|Yo)${PUNCTUATION.en}* (.)`, 'i'),\n        // Capitalise the first letter.\n        (match, letter) => letter.toUpperCase()\n      );\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","// @todo Use a POS tagger and reorganise element in questions:\n// * \"Tell me where you are.\" => \"Where are you?\"\nexport default class PolitenessCleaner {\n  clean(obj = { cleaned: '' }) {\n    const cleaned = obj.cleaned\n      .replace(\n        new RegExp('^(?:' +\n          '|Could you please ' +\n          '|Please could you ' +\n          '|Could you ' +\n          '|Would you please ' +\n          '|Please would you ' +\n          '|Would you ' +\n          '|Will you please ' +\n          '|Please will you ' +\n          '|Will you ' +\n          '|Can you please ' +\n          '|Please can you ' +\n          '|Can you ' +\n          '|Please do ' +\n          '|Please ' +\n          ')?(.)', 'i'),\n        // Capitalise the first letter.\n        (match, letter) => letter.toUpperCase()\n      );\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","export default class QuestionsCleaner {\n  clean(obj = { cleaned: '' }) {\n    let cleaned = obj.cleaned\n      .replace(\n        new RegExp('^(?:Tell me ' +\n          '|Let me know ' +\n          '|Inform me ' +\n          '|I want to know ' +\n          ')wh(at|ere|en|o)\\\\b', 'i'),\n        'Wh$1'\n      );\n\n    if (cleaned !== obj.cleaned) {\n      if (cleaned.match(/^Wh(at|ere|en|o)\\b/i)) {\n        // Add question mark if it is a question.\n        cleaned = cleaned.replace(/\\.+$/, '?');\n      }\n    }\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","import chrono from 'chrono-node';\n\n/**\n * Parse day periods according to CLDR.\n * @see http://www.unicode.org/cldr/charts/29/verify/dates/en.html\n */\nconst dayPeriodsParser = new chrono.Parser();\ndayPeriodsParser.pattern =\n  () => new RegExp('midnight|morning|in the morning|noon|' +\n    'afternoon|in the afternoon|evening|in the evening|night|at night', 'i');\ndayPeriodsParser.extract = (text, ref, match) => {\n  let hour;\n  let meridiem;\n\n  switch (match[0].toLowerCase()) {\n    case 'midnight':\n      hour = 0;\n      meridiem = 0;\n      break;\n    case 'morning':\n    case 'in the morning':\n      hour = 9;\n      meridiem = 0;\n      break;\n    case 'noon':\n      hour = 12;\n      meridiem = 1;\n      break;\n    case 'afternoon':\n    case 'in the afternoon':\n      hour = 15;\n      meridiem = 1;\n      break;\n    case 'evening':\n    case 'in the evening':\n      hour = 18;\n      meridiem = 1;\n      break;\n    case 'night':\n    case 'at night':\n      hour = 22;\n      meridiem = 1;\n      break;\n    default:\n      break;\n  }\n\n  return new chrono.ParsedResult({\n    ref,\n    text: match[0],\n    index: match.index,\n    start: {\n      hour,\n      meridiem,\n    },\n  });\n};\n\n/**\n * When the meridiem is not specified, set the time to after the current time.\n * `at 5 today` (current time is 3pm) => `5pm`.\n */\nconst forwardHoursRefiner = new chrono.Refiner();\nforwardHoursRefiner.refine = (text, results, opt = {}) => {\n  if (opt.forwardHoursOnly !== true) {\n    return results;\n  }\n\n  // If the date is today and there is no AM/PM (meridiem) specified,\n  // let all the time be after the current time.\n  results.forEach((result) => {\n    changeDate(result.start, result.ref);\n    if (result.end) {\n      changeDate(result.end, result.ref);\n    }\n  });\n\n  return results;\n\n  function changeDate(component, ref) {\n    if (!component.isCertain('meridiem')\n      && component.moment(ref).isSame(component, 'day')\n      && component.get('hour') <= ref.getHours()) {\n      component.assign('meridiem', 1);\n      component.assign('hour', component.get('hour') + 12);\n    }\n  }\n};\n\nconst customChrono = new chrono.Chrono(chrono.options.casualOption());\ncustomChrono.parsers.push(dayPeriodsParser);\ncustomChrono.refiners.push(forwardHoursRefiner);\n\nexport default {\n  parse: (phrase) => customChrono.parse(phrase, null, {\n    forwardDate: true,\n    forwardDatesOnly: true,\n    forwardHoursOnly: true,\n  }),\n};\n","import chrono from './chrono/chrono';\n\nconst p = Object.freeze({\n  normaliseTimes: Symbol('normaliseTimes'),\n});\n\n/**\n * Current bugs about time extraction from the original text:\n * * The time expressions starting by \"on\" or \"by\" are not correctly extracted.\n *   e.g. \"The sale on Sunday\" => \"The sale on\" (Incorrect)\n *   e.g. \"The sale at 12p.m.\" => \"The sale\" (Correct)\n *\n * * When a time frame is set, the \"from\" should be extracted too.\n *   e.g. \"I'm busy from Mon to Tue\" => \"I'm busy from\"\n *\n * * When multiple dates are specified, they should all be removed.\n *   e.g. \"I'm busy on Wed and Thurs\" =>\n *        [\"I'm busy on and Thurs\", \"I'm busy on Wed and\"]\n */\nexport default class TimeParser {\n  parse(obj = { cleaned: '' }) {\n    const text = this[p.normaliseTimes](obj.cleaned);\n    const dates = chrono.parse(text);\n\n    if (!dates.length) {\n      obj.time = null;\n      return Promise.resolve(obj);\n    }\n\n    const time = dates.map((date) => {\n      const start = date.start ? Number(date.start.date()) : null;\n      const end = date.end ? Number(date.end.date()) : null;\n      const extractedText = date.text;\n      const processedText = text.substr(0, date.index) +\n        text.substr(date.index + extractedText.length);\n\n      return { start, end, extractedText, processedText };\n    });\n\n    obj.time = time;\n\n    return Promise.resolve(obj);\n  }\n\n  [p.normaliseTimes](text = '') {\n    // The Web Speech API returns PM hours as `p.m.`.\n    return text\n      .replace(/([0-9]) ?p\\.m\\./gi, '$1 PM')\n      .replace(/([0-9]) ?a\\.m\\./gi, '$1 AM');\n  }\n}\n","const PATTERNS = {\n  en: {\n    patterns: [\n      /^Remind (.+?) (?:to|at|on|by|that|about)\\b/i,\n      /^Where (?:am|are|is) (.+?) (?:at|on|by)\\b/i,\n      /^Where (?:am|are|is) (.+?) supposed to\\b/i,\n      /^Where should (.+?) go\\b/i,\n      /^What (?:am|are|is) (.+?) doing\\b/i,\n      /^What (?:am|are|is) (.+?) supposed to\\b/i,\n      /^What should (.+?) do\\b/i,\n      /^What (?:do|does) (.+?) do\\b/i,\n      /^What is (.+?)(?:'s)? (?:schedule|planning|calendar|agenda)\\b/i,\n      /([^ ]+ (?:and|&) [^ ]+)/i, // @todo Improve with more patterns.\n    ],\n    // @see http://www.unicode.org/cldr/charts/29/summary/en.html#6402\n    listBreaker: /,? (?:and|&) |, /gi,\n  },\n\n  fr: {\n    patterns: [\n      /Rappelle (.+?) de (?:.+)/i,\n      /Rappelle (.+?) d'(?:.+)/i,\n      /Rappelle-(.+?) de (?:.+)/i,\n      /Rappelle-(.+?) d'(?:.+)/i,\n    ],\n    listBreaker: /,? (?:et|&) |, /gi,\n  },\n\n  ja: {\n    patterns: [\n      /(?:.+)を(.+)に思い出させて/i,\n      /(.+)に(?:.+)を思い出させて/i,\n      /(.+)は(?:.+)と言うリマインダーを作成して/i,\n    ],\n    listBreaker: /、/gu,\n  },\n};\n\nconst p = Object.freeze({\n  users: Symbol('users'),\n  normalise: Symbol('normalise'),\n});\n\n// @todo Import and use the list of users when multiusers db is ready.\nexport default class UsersParser {\n  constructor(users = []) {\n    this[p.users] = users;\n  }\n\n  parse(obj = { cleaned: '' }) {\n    const text = obj.cleaned;\n    let users = null;\n\n    PATTERNS.en.patterns.some((pattern) => {\n      const match = pattern.exec(text);\n\n      if (!match) {\n        return false;\n      }\n\n      users = this.parseUsers(match[1]);\n      return !!users.length;\n    });\n\n    obj.recipients = users;\n\n    return Promise.resolve(obj);\n  }\n\n  parseUsers(string = '') {\n    return string\n      .split(PATTERNS.en.listBreaker)\n      .map((user) => user.trim())\n      .filter((user) => !!user);\n  }\n}\n","const PATTERNS = {\n  en: {\n    patterns: [\n      /Remind (?:.+?) (?:to|at|on|by|that|about) (.+)/i,\n      /Remind (?:.+?) that (?:it|there) is (.+)/i,\n    ],\n    // @see http://www.unicode.org/cldr/charts/29/summary/en.html#4\n    punctuation: /[-‐–—,;:!?.…'‘’\"“”()[\\]§@*/&#†‡′″]+$/,\n  },\n\n  fr: {\n    patterns: [\n      /Rappelle (?:.+?) de (.+)/i,\n      /Rappelle (?:.+?) d'(.+)/i,\n      /Rappelle-(?:.+?) de (.+)/i,\n      /Rappelle-(?:.+?) d'(.+)/i,\n    ],\n    punctuation: /[-‐–—,;:!?.…’\"“”«»()[\\]§@*/&#†‡]+$/,\n  },\n\n  ja: {\n    patterns: [\n      /(.+)を(?:.+)に思い出させて/i,\n      /(?:.+)に(.+)を思い出させて/i,\n      /(?:.+)は(.+)と言うリマインダーを作成して/i,\n    ],\n    // eslint-disable-next-line max-len\n    punctuation: /[-‾_＿－‐—―〜・･,，、､;；:：!！?？.．‥…。｡＇‘’\"＂“”(（)）[［\\]］{｛}｝〈〉《》「｢」｣『』【】〔〕‖§¶@＠*＊/／\\\\＼&＆#＃%％‰†‡′″〃※]+$/u,\n  },\n};\n\nconst p = Object.freeze({\n  normalise: Symbol('normalise'),\n  parseNoDates: Symbol('parseNoDates'),\n  parseMultipleDates: Symbol('parseMultipleDates'),\n});\n\nexport default class ActionParser {\n  parse(obj = { cleaned: '', time: [] }) {\n    let action = null;\n\n    if (obj.time === null) {\n      // We use the original phrase.\n      const text = this[p.normalise](obj.cleaned);\n      action = this[p.parseNoDates](text);\n    } else if (obj.time.length === 1) {\n      // We use the original phrase with the time extracted out.\n      const text = this[p.normalise](obj.time[0].processedText);\n      action = this[p.parseNoDates](text);\n    } else if (obj.time.length > 1) {\n      const text = this[p.normalise](obj.cleaned);\n      action = this[p.parseMultipleDates](text);\n    }\n\n    obj.action = action;\n\n    return Promise.resolve(obj);\n  }\n\n  [p.normalise](string = '') {\n    return string\n    // Strip punctuations.\n      .replace(PATTERNS.en.punctuation, '')\n      .trim();\n  }\n\n  /**\n   * Extract an action from a sentence that has no time references.\n   *\n   * @param {string} text\n   * @return {string}\n   */\n  [p.parseNoDates](text = '') {\n    let action = null;\n\n    PATTERNS.en.patterns.some((pattern) => {\n      const match = pattern.exec(text);\n\n      if (!match) {\n        return false;\n      }\n\n      action = match[1];\n      return true;\n    });\n\n    return action;\n  }\n\n  [p.parseMultipleDates]() {\n    // @todo Implement me.\n    console.error('Parsing action with multiple time references is not ' +\n      'implemented yet.');\n    return null;\n  }\n}\n","/* global TwitterCldr, TwitterCldrDataBundle */\n\nimport moment from 'moment';\n\n/*\n * @todo:\n *   * @see http://www.unicode.org/cldr/charts/29/verify/dates/en.html\n *     for formatting the time of the day.\n */\n\nconst p = Object.freeze({\n  // Properties\n  listFormatter: Symbol('listFormatter'),\n\n  // Methods\n  getLocalised: Symbol('getLocalised'),\n  formatUser: Symbol('formatUser'),\n  formatAction: Symbol('formatAction'),\n  formatTime: Symbol('formatTime'),\n  isToday: Symbol('isToday'),\n  isTomorrow: Symbol('isTomorrow'),\n  isThisMonth: Symbol('isThisMonth'),\n  formatHoursAndMinutes: Symbol('formatHoursAndMinutes'),\n});\n\nconst DEFAULT_LOCALE = 'en';\nconst PATTERNS = {\n  en: {\n    template: `OK, I'll remind [users] [action] [time].`,\n    formatUser: (user) => user\n      .replace(/\\bme\\b/gi, 'you')\n      .replace(/\\bI am\\b/gi, 'you are')\n      .replace(/\\bI have\\b/gi, 'you have')\n      .replace(/\\bI will\\b/gi, 'you will')\n      .replace(/\\bI\\b/gi, 'you')\n      .replace(/\\bmy\\b/gi, 'your')\n      .replace(/\\bmine\\b/gi, 'yours'),\n  },\n  fr: {\n    template: `OK, je rappelerai [users] [action] [time].`,\n    formatUser: (user) => user,\n  },\n  ja: {\n    template: `承知しました。[time][users]に[action]をリマインドします。`,\n    formatUser: (user) => user,\n  },\n};\n\nexport default class ReminderConfirmation {\n  constructor(locale = DEFAULT_LOCALE) {\n    this.locale = locale;\n\n    if (typeof TwitterCldr === 'undefined') {\n      this[p.listFormatter] = {\n        format: (a) => a.join(' and '),\n      };\n    } else {\n      TwitterCldr.set_data(TwitterCldrDataBundle);\n      this[p.listFormatter] = new TwitterCldr.ListFormatter();\n    }\n  }\n\n  /**\n   * Generate a phrase to be spoken to confirm a reminder.\n   *\n   * @param {Object} reminder\n   * @return {string}\n   */\n  confirm(reminder) {\n    const template = this[p.getLocalised]('template');\n    const data = {\n      users: this[p.formatUser](reminder),\n      action: this[p.formatAction](reminder),\n      time: this[p.formatTime](reminder),\n    };\n\n    return template.replace(/\\[([^\\]]+)\\]/g, (match, placeholder) => {\n      return data[placeholder];\n    });\n  }\n\n  /**\n   * Given a property of the PATTERNS object, returns the one matching the\n   * current locale or the default one if non existing.\n   *\n   * @param {string} prop\n   * @returns {*}\n   */\n  [p.getLocalised](prop) {\n    let locale = this.locale;\n    if (!PATTERNS[this.locale] || !PATTERNS[this.locale][prop]) {\n      locale = DEFAULT_LOCALE;\n    }\n\n    return PATTERNS[locale][prop];\n  }\n\n  [p.formatUser]({ recipients }) {\n    const formatUser = this[p.getLocalised]('formatUser');\n    const formattedUsers = recipients.map(formatUser);\n    return this[p.listFormatter].format(formattedUsers);\n  }\n\n  [p.formatAction]({ action, cleaned }) {\n    const formatUser = this[p.getLocalised]('formatUser');\n    const formattedAction = formatUser(action);\n\n    const PATTERN1 = new RegExp(`\\\\bthat ${action}`, 'i');\n    const PATTERN2 = new RegExp(`\\\\bit is ${action}`, 'i');\n    const PATTERN3 = new RegExp(`\\\\bthere is ${action}`, 'i');\n    const PATTERN4 = new RegExp(`\\\\babout ${action}`, 'i');\n\n    if (PATTERN1.test(cleaned)) {\n      return `that ${formattedAction}`;\n    } else if (PATTERN2.test(cleaned)) {\n      return `that it is ${formattedAction}`;\n    } else if (PATTERN3.test(cleaned)) {\n      return `that there is ${formattedAction}`;\n    } else if (PATTERN4.test(cleaned)) {\n      return `about ${formattedAction}`;\n    }\n\n    return `to ${formattedAction}`;\n  }\n\n  [p.formatTime]({ due }) {\n    if (this[p.isToday](due)) {\n      const hour = this[p.formatHoursAndMinutes](due);\n      return `at ${hour} today`;\n    } else if (this[p.isTomorrow](due)) {\n      const hour = this[p.formatHoursAndMinutes](due);\n      return `at ${hour} tomorrow`;\n      // @todo Add a pattern here with the weekday if within 7 days.\n    } else if (this[p.isThisMonth](due)) {\n      return moment(due).format('[on the] Do');\n    }\n\n    return moment(due).format('[on] MMMM [the] Do');\n  }\n\n  [p.isToday](date) {\n    const today = moment().startOf('day');\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    return moment(date).isBetween(today, tomorrow);\n  }\n\n  [p.isTomorrow](date) {\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    const in2days = moment().add(2, 'day').startOf('day');\n    return moment(date).isBetween(tomorrow, in2days);\n  }\n\n  [p.isThisMonth](date) {\n    const thisMonth = moment().startOf('month');\n    const nextMonth = moment().add(1, 'month').startOf('month');\n    return moment(date).isBetween(thisMonth, nextMonth);\n  }\n\n  /**\n   * Return a string from a date suitable for speech synthesis.\n   *\n   * @param {Date} date\n   * @return {string}\n   */\n  [p.formatHoursAndMinutes](date) {\n    date = moment(date);\n    let format;\n\n    if (date.minute() === 0) {\n      format = date.format('h A'); // 7 PM\n    } else if (date.minute() === 15) {\n      format = date.format('[quarter past] h A');\n    } else if (date.minute() === 30) {\n      format = date.format('[half past] h A');\n    } else if (date.minute() === 45) {\n      const nextHour = date.add(1, 'hour');\n      format = nextHour.format('[quarter to] h A');\n    } else {\n      format = date.format('h:m A'); // 6:24 AM\n    }\n\n    // Some speech synthesisers pronounce \"AM\" as in \"ham\" (not \"A. M.\").\n    return format\n      .replace(/([0-9]) ?AM$/gi, '$1 A.M.')\n      .replace(/([0-9]) ?PM$/gi, '$1 P.M.');\n  }\n}\n","import ReminderConfirmation from './confirmations/reminder-confirmation';\n\nconst p = Object.freeze({\n  reminderConfirmation: Symbol('reminderConfirmation'),\n});\n\nexport default class ReminderRefiner {\n  constructor() {\n    this[p.reminderConfirmation] = new ReminderConfirmation();\n  }\n\n  /**\n   * A reminder is an intent that:\n   *  * Starts with \"Remind\"\n   *  * Has a single time reference\n   *  * Has at least 1 user\n   *  * Has an action\n   *\n   * @param {Object} obj\n   * @returns {Promise}\n   */\n  refine(obj = {}) {\n    const hasTime = obj.time !== null\n      && obj.time.length === 1\n      && obj.time[0].start !== null\n      && obj.time[0].end === null;\n    const hasUsers = obj.recipients !== null\n      && obj.recipients.length > 0;\n    const hasAction = obj.action !== null;\n\n    if (obj.cleaned.toLowerCase().startsWith('remind')\n      && hasTime\n      && hasUsers\n      && hasAction) {\n      obj.due = obj.time[0].start;\n      obj.confirmation = this[p.reminderConfirmation].confirm(obj);\n      obj.intent = 'reminder';\n    }\n\n    return Promise.resolve(obj);\n  }\n}\n","/* global TwitterCldr, TwitterCldrDataBundle */\n\nimport moment from 'moment';\n\nconst p = Object.freeze({\n  // Properties\n  time: Symbol('time'),\n  users: Symbol('users'),\n  listFormatter: Symbol('listFormatter'),\n\n  // Methods\n  formatTime: Symbol('formatTime'),\n  isToday: Symbol('isToday'),\n  isTomorrow: Symbol('isTomorrow'),\n  isThisMonth: Symbol('isThisMonth'),\n  formatHoursAndMinutes: Symbol('formatHoursAndMinutes'),\n});\n\nconst PATTERNS = {\n  en: {\n    formatUser: (user) => user\n      .replace(/\\bme\\b/gi, 'you')\n      .replace(/\\bI am\\b/gi, 'you are')\n      .replace(/\\bI have\\b/gi, 'you have')\n      .replace(/\\bI will\\b/gi, 'you will')\n      .replace(/\\bI\\b/gi, 'you')\n      .replace(/\\bmy\\b/gi, 'your')\n      .replace(/\\bmine\\b/gi, 'yours'),\n  },\n  fr: {\n    formatUser: (user) => user,\n  },\n  ja: {\n    formatUser: (user) => user,\n  },\n};\n\nexport default class QueryConfirmation {\n  constructor({ due, recipients }) {\n    if (typeof TwitterCldr === 'undefined') {\n      this[p.listFormatter] = {\n        format: (a) => a.join(' and '),\n      };\n    } else {\n      TwitterCldr.set_data(TwitterCldrDataBundle);\n      this[p.listFormatter] = new TwitterCldr.ListFormatter();\n    }\n\n    this[p.time] = due;\n    this[p.users] = recipients;\n  }\n\n  confirm(reminder) {\n    // We use the users from the original query rather than the found reminder.\n    const users = this[p.formatUser](this[p.users]);\n\n    if (!reminder) {\n      const time = this[p.formatTime]({ due: this[p.time] });\n      return `I can't find anything scheduled for ${users} ${time}.`;\n    }\n\n    const action = reminder.action;\n    const time = this[p.formatTime](reminder);\n\n    if (users === 'you' || this[p.users].length >= 1) {\n      return `${time}, ${users} have the following activity: \"${action}\".`;\n    }\n\n    return `${time}, ${users} has the following activity: \"${action}\".`;\n  }\n\n  [p.formatUser](users) {\n    const formattedUsers = users.map(PATTERNS.en.formatUser);\n    return this[p.listFormatter].format(formattedUsers);\n  }\n\n  [p.formatTime]({ due }) {\n    const hour = this[p.formatHoursAndMinutes](due);\n\n    if (this[p.isToday](due)) {\n      return `at ${hour} today`;\n    } else if (this[p.isTomorrow](due)) {\n      return `at ${hour} tomorrow`;\n      // @todo Add a pattern here with the weekday if within 7 days.\n    } else if (this[p.isThisMonth](due)) {\n      const day = moment(due).format('Do');\n      return `at ${hour} on the ${day}`;\n    }\n\n    const day = moment(due).format('MMMM [the] Do');\n    return `at ${hour} on ${day}`;\n  }\n\n  [p.isToday](date) {\n    const today = moment().startOf('day');\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    return moment(date).isBetween(today, tomorrow);\n  }\n\n  [p.isTomorrow](date) {\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    const in2days = moment().add(2, 'day').startOf('day');\n    return moment(date).isBetween(tomorrow, in2days);\n  }\n\n  [p.isThisMonth](date) {\n    const thisMonth = moment().startOf('month');\n    const nextMonth = moment().add(1, 'month').startOf('month');\n    return moment(date).isBetween(thisMonth, nextMonth);\n  }\n\n  /**\n   * Return a string from a date suitable for speech synthesis.\n   *\n   * @param {Date} date\n   * @return {string}\n   */\n  [p.formatHoursAndMinutes](date) {\n    date = moment(date);\n    let format;\n\n    if (date.minute() === 0) {\n      format = date.format('h A'); // 7 PM\n    } else if (date.minute() === 15) {\n      format = date.format('[quarter past] h A');\n    } else if (date.minute() === 30) {\n      format = date.format('[half past] h A');\n    } else if (date.minute() === 45) {\n      const nextHour = date.add(1, 'hour');\n      format = nextHour.format('[quarter to] h A');\n    } else {\n      format = date.format('h:m A'); // 6:24 AM\n    }\n\n    // Some speech synthesisers pronounce \"AM\" as in \"ham\" (not \"A. M.\").\n    return format\n      .replace(/([0-9]) ?AM$/gi, '$1 A.M.')\n      .replace(/([0-9]) ?PM$/gi, '$1 P.M.');\n  }\n}\n","import QueryConfirmation from './confirmations/query-confirmation';\n\nconst PATTERNS = {\n  en: {\n    formatUser: (user) => user\n      .replace(/\\bI\\b/gi, 'me')\n      .replace(/\\bmy\\b/gi, 'me')\n      .replace(/\\bmine\\b/gi, 'me'),\n  },\n  fr: {\n    formatUser: (user) => user,\n  },\n  ja: {\n    formatUser: (user) => user,\n  },\n};\n\n// @todo Handle the case where a time range is specified.\nexport default class QueryRefiner {\n  /**\n   * A query is an intent that:\n   *  * Looks like a question\n   *  * Has a single time reference\n   *  * Has at least 1 user\n   *  * Has no actions\n   *\n   * @param {Object} obj\n   * @returns {Promise}\n   */\n  refine(obj = {}) {\n    const hasTime = obj.time !== null\n      && obj.time.length === 1\n      && obj.time[0].start !== null\n      && obj.time[0].end === null;\n    const hasUsers = obj.recipients !== null\n      && obj.recipients.length > 0;\n    const hasNoActions = obj.action === null;\n\n    if (obj.cleaned.match(/^(?:What|Where|When)/i)\n      && hasTime\n      && hasUsers\n      && hasNoActions) {\n      const queryConfirmation = new QueryConfirmation({\n        due: obj.time[0].start,\n        recipients: obj.recipients,\n      });\n\n      obj.due = obj.time[0].start;\n      obj.recipients = obj.recipients.map(PATTERNS.en.formatUser);\n      obj.confirmation = queryConfirmation.confirm.bind(queryConfirmation);\n      obj.intent = 'query';\n    }\n\n    return Promise.resolve(obj);\n  }\n}\n","import NormaliseCleaner from './cleaners/normalise-cleaner';\nimport ContractionsCleaner from './cleaners/contractions-cleaner';\nimport SalutationsCleaner from './cleaners/salutations-cleaner';\nimport PolitenessCleaner from './cleaners/politeness-cleaner';\nimport QuestionsCleaner from './cleaners/questions-cleaner';\n\nimport TimeParser from './parsers/time-parser';\nimport UsersParser from './parsers/users-parser';\nimport ActionParser from './parsers/action-parser';\n\nimport ReminderRefiner from './refiners/reminder-refiner';\nimport QueryRefiner from './refiners/query-refiner';\n\nconst p = Object.freeze({\n  // Properties\n  cleaners: Symbol('cleaners'),\n  parsers: Symbol('parsers'),\n  refiners: Symbol('refiners'),\n});\n\nexport default class IntentParser {\n  constructor() {\n    this[p.cleaners] = [\n      new NormaliseCleaner(), // Always keep this one first.\n      new ContractionsCleaner(),\n      new SalutationsCleaner(),\n      new PolitenessCleaner(),\n      new QuestionsCleaner(), // Must go after PolitenessCleaner`\n    ];\n    this[p.parsers] = [\n      new TimeParser(),\n      new UsersParser(),\n      new ActionParser(),\n    ];\n    this[p.refiners] = [\n      new ReminderRefiner(),\n      new QueryRefiner(),\n    ];\n\n    // Add it to the global scope for debugging.\n    // eslint-disable-next-line no-new-func\n    const global = new Function('return this')();\n    global.intentParser = this;\n    // eslint-enable\n  }\n\n  parse(text = '') {\n    text = String(text);\n\n    const result = {\n      raw: text, // Leave this untouched for debugging purposes.\n      intent: null,\n    };\n\n    const cleaningPromises = this[p.cleaners]\n      .map((cleaner) => cleaner.clean.bind(cleaner));\n    const parsingPromises = this[p.parsers]\n      .map((parser) => parser.parse.bind(parser));\n    const refiningPromises = this[p.refiners]\n      .map((refiner) => refiner.refine.bind(refiner));\n\n    return new Promise((resolve, reject) => {\n      Promise.resolve(result)\n      // Cleaning phase.\n        .then((result) => cleaningPromises\n          .reduce((p, val) => p.then(val), Promise.resolve(result)))\n\n        // Parsing phase.\n        .then((result) => parsingPromises\n          .reduce((p, val) => p.then(val), Promise.resolve(result)))\n\n        // Refining phase.\n        .then((result) => refiningPromises\n          .reduce((p, val) => p.then(val), Promise.resolve(result))\n        )\n\n        // Final result.\n        .then((result) => {\n          if (result.intent === null) {\n            console.error('The intent could not be parsed:', result);\n            return reject(null);\n          }\n\n          return resolve(result);\n        });\n    });\n  }\n}\n"],"names":["NormaliseCleaner","clean","obj","raw","text","replace","trim","cleaned","Promise","resolve","ContractionsCleaner","RegExp","PUNCTUATION","SalutationsCleaner","en","match","letter","toUpperCase","PolitenessCleaner","QuestionsCleaner","dayPeriodsParser","chrono","Parser","pattern","extract","ref","hour","meridiem","toLowerCase","ParsedResult","index","forwardHoursRefiner","Refiner","refine","results","changeDate","component","isCertain","moment","isSame","get","getHours","assign","opt","forwardHoursOnly","forEach","result","start","end","customChrono","Chrono","options","casualOption","parsers","push","refiners","phrase","parse","p","Object","freeze","Symbol","TimeParser","this","normaliseTimes","dates","length","time","map","date","Number","extractedText","processedText","substr","PATTERNS","UsersParser","users","patterns","some","exec","_this","parseUsers","recipients","string","split","listBreaker","user","filter","ActionParser","action","normalise","parseNoDates","parseMultipleDates","punctuation","error","DEFAULT_LOCALE","ReminderConfirmation","locale","TwitterCldr","listFormatter","a","join","set_data","TwitterCldrDataBundle","ListFormatter","confirm","reminder","template","getLocalised","data","formatUser","formatAction","formatTime","placeholder","prop","formattedUsers","format","formattedAction","PATTERN1","PATTERN2","PATTERN3","PATTERN4","test","due","isToday","formatHoursAndMinutes","isTomorrow","isThisMonth","today","startOf","tomorrow","add","isBetween","in2days","thisMonth","nextMonth","minute","nextHour","ReminderRefiner","reminderConfirmation","hasTime","hasUsers","hasAction","startsWith","confirmation","intent","QueryConfirmation","day","QueryRefiner","hasNoActions","queryConfirmation","bind","IntentParser","cleaners","global","Function","intentParser","String","cleaningPromises","cleaner","parsingPromises","parser","refiningPromises","refiner","reject","then","reduce","val"],"mappings":"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"}